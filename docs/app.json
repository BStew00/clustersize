[{"name":"app.R","content":"\r\nlibrary(shiny)\r\nlibrary(munsell)\r\nenableBookmarking(store = \"url\")\r\nshinyAppDir(getwd())#,list(enableBookmarking = \"url\"))#Bookmarking not currently supported in Shinylive\r\n\r\n","type":"text"},{"name":"server.R","content":"# GitHub: https://github.com/CDCgov/Study_Design_Tools_for_Complex_Cluster_Surveys\r\n# App: https://cdcgov.github.io/Study_Design_Tools_for_Complex_Cluster_Surveys/\r\n#\r\n# Server code for Shinylive app\r\n\r\n# Logical: checks to see if input is:\r\n# a number, i.e. one or more digits [0-9] optionally immediatelly followed by a decimal point and one or more digits \r\n# OR\r\n# a decimal number without the leading zero\r\n# OR\r\n# a fraction, i.e. a number immediately followed by a slash immediately followed by a number\r\n# Note: currently does not allow numerator or denominator of fraction to be a decimal number unless it has a leading zero\r\nnumericInputIsValid = function(x){\r\n  grepl(\"^\\\\d+(\\\\.\\\\d+)?$\", x) | \r\n  grepl(\"^\\\\.\\\\d+$\", x) | \r\n  grepl(\"^\\\\d+(\\\\.\\\\d+)?/\\\\d+(\\\\.\\\\d+)?$\", x)\r\n}\r\n\r\n# Convert input from ui format to numerical format suitable for server code\r\npreparedNumericalInput = function(x){\r\n  if(length(x)>1)x=paste(x,collapse=\", \")# handle selectInput values being character vector instead of a character string\r\n  trimws(strsplit(x,\",\")[[1]])\r\n}\r\n\r\n# Logical: check whether numeric input is in correct format\r\ninputIsOk = function(x){\r\n  all(numericInputIsValid(x))\r\n}\r\n\r\n# Take the string input, convert to numeric. Handles fractions.\r\nconvertNumericInput = function(x,nm){\r\n  x = preparedNumericalInput(x)\r\n  if(inputIsOk(x)){\r\n    val = rep(0,length(x))\r\n    for(i in 1:length(x)){\r\n      if(grepl(\"/\",x[i])){\r\n        val[i] = as.numeric(eval(parse(text=x[i])))\r\n      } else {\r\n        val[i] = as.numeric(x[i])\r\n      }\r\n    }\r\n    val\r\n  } else {\r\n    stop(\"Please enter only numbers and/or valid fractions separated by commas, e.g., 1/2, 3.5/4, 0.05, 200\")\r\n  }\r\n}\r\n\r\n# Provide feedback on improper inputs\r\nfeedbackOnInput = function(x,nm){\r\n  x = preparedNumericalInput(x)\r\n  shinyFeedback::feedbackDanger(nm, !inputIsOk(x), \"invalid input, see error message\")\r\n}\r\ngiveFeedbackOnInputs = function(x,nm){\r\n  for(k in nm)feedbackOnInput(x[[k]],k)\r\n}\r\n\r\n# Return the inputs specified by names as a list of numeric vectors\r\ngetNumericInputs = function(names, x=input){\r\n  i = reactiveValues()\r\n  for(k in names)i[[k]]=convertNumericInput(x[[k]],k)\r\n  i\r\n}\r\n\r\ngetFunArgNames = function(fun_name)names(formals(get(fun_name)))\r\ngetICIDforFun = function(fun_name)paste0(fun_name,\"_\",getFunArgNames(fun_name))\r\n\r\ngetOutputUsingFun = function(fun_name,input,...){\r\n  unm = getICIDforFun(fun_name)\r\n  fnm = getFunArgNames(fun_name)\r\n  if(input$study_type==\"Classification\")unm=unm[!unm==\"nclOutTab_direction\"]\r\n  ii = getNumericInputs(unm, input)  \r\n  vals = reactiveValues()\r\n  for(k in fnm)vals[[k]]=ii[[paste0(fun_name,\"_\",k)]]\r\n  vals = reactiveValuesToList(vals)\r\n  if(input$study_type==\"Classification\")vals$direction=paste0(\"'\",input$nclOutTab_direction,\"'\")\r\n  aLst = list(...)\r\n  if(\"expandForPlot\" %in% names(aLst)){\r\n    k = aLst$expandForPlot\r\n    vals[[k]] = seq(min(vals[[k]]),max(vals[[k]]),length.out=aLst$x_gran)\r\n  }\r\n  txt = paste0(fun_name,paste0(\"(\",paste(paste(fnm,vals,sep=\"=\"),collapse=\" , \"),\")\"))\r\n  eval(parse(text=txt))\r\n}\r\n\r\n# Makes table of sample sizes for Estimation studies\r\nmakeOutputTable = function(input){\r\n  if(input$study_type == \"Estimation\"){\r\n    if(input$calc_type == \"Sample size\"){\r\n      val = getOutputUsingFun(\"nOutTab\",input)\r\n    }\r\n    if(input$calc_type == \"Half-width CI\"){\r\n      val = getOutputUsingFun(\"dOutput\",input)\r\n    }\r\n  }\r\n  if(input$study_type == \"Classification\"){\r\n    if(TRUE){\r\n      val = getOutputUsingFun(\"nclOutTab\",input)\r\n    }\r\n  }\r\n  if(input$study_type == \"Comparison\"){\r\n    if(TRUE){\r\n      if(input$calc_type_Com == \"2 Group, 2-Sided\"){\r\n        val = getOutputUsingFun(\"ESS_2Grp_2Sided\",input)\r\n      }\r\n      if(input$calc_type_Com == \"1 Group, 1-Sided\"){\r\n        val = getOutputUsingFun(\"ESS_1Grp_1Sided\",input)\r\n      }\r\n    }\r\n  }\r\n  val\r\n}\r\n\r\n\r\n\r\nsource(\"functions.R\")\r\nsource(\"output.R\")\r\nsource(\"Sample size 2 group design.R\")\r\n\r\n\r\nserver = function(input, output, session) {\r\n  output$dev = renderPrint({\r\n    print(input)\r\n    print(input$study_type)\r\n    if(input$study_type==\"Estimation\")print(input$calc_type)\r\n    if(input$study_type==\"Comparison\")print(input$calc_type_Com)\r\n    for(k in numeric_input_names())print(paste(k,input[[k]]))\r\n  })\r\n  \r\n  # Reactive values\r\n  output_table = reactive({makeOutputTable(input)})\r\n  numeric_input_names = reactive({\r\n    switch(\r\n      input$study_type,\r\n        \"Estimation\"=switch(\r\n          input$calc_type,\r\n            \"Sample size\"=getICIDforFun(\"nOutTab\"),\r\n            \"Half-width CI\"=getICIDforFun(\"dOutput\")\r\n        ),\r\n        \"Classification\"=getICIDforFun(\"nclOutTab\")[!getICIDforFun(\"nclOutTab\")==\"nclOutTab_direction\"],\r\n        \"Comparison\"=switch(\r\n          input$calc_type_Com,\r\n            \"2 Group, 2-Sided\"=getICIDforFun(\"ESS_2Grp_2Sided\"),\r\n            \"1 Group, 1-Sided\"=getICIDforFun(\"ESS_1Grp_1Sided\")\r\n          )\r\n    )\r\n  })\r\n\r\n  # Give feedback on inputs\r\n  toListen = reactive({\r\n    i = reactiveValues()\r\n    for(k in numeric_input_names())i[[k]]=input[[k]]\r\n    i\r\n  })\r\n  observeEvent({toListen()},{\r\n    giveFeedbackOnInputs(input,numeric_input_names())\r\n  })\r\n\r\n  # Create display table\r\n  output$ESSdf = renderTable({\r\n      output_table()\r\n  }, striped=TRUE\r\n  )\r\n\r\n\r\n\r\n  # Set granularity of the plot lines\r\n  x_gran = 10\r\n\r\n  output$plot1 = renderPlot({\r\n    dat = getOutputUsingFun(\"nOutTab\",input,expandForPlot=\"d\",x_gran=x_gran)\r\n    dat$p = as.factor(dat$p)\r\n    ggplot2::ggplot(dat, ggplot2::aes(x = d, y = dat[,\"n(ess,deff,inf)\"], color = interaction(p,m,icc,cv,r,alpha), group = interaction(p,m,icc,cv,r,alpha))) +\r\n      ggplot2::geom_line(size = 1) + ggplot2::geom_point() + \r\n      ggplot2::labs(title = \"Sample Size as a function of CI Half-Width\", y = \"Sample Size\", x = \"CI Half-Width\") +\r\n      ggplot2::theme_minimal() + ggplot2::theme(legend.position=\"bottom\")\r\n  })\r\n  output$plot2 = renderPlot({\r\n    dat = getOutputUsingFun(\"nOutTab\",input,expandForPlot=\"p\",x_gran=x_gran)\r\n    ggplot2::ggplot(dat, ggplot2::aes(x = p, y = dat[,\"n(ess,deff,inf)\"], color = interaction(d,m,icc,cv,r,alpha), group = interaction(d,m,icc,cv,r,alpha))) +\r\n      ggplot2::geom_line(size = 1) + ggplot2::geom_point() + \r\n      ggplot2::labs(title = \"Sample Size as a function of Expected coverage proportion\", y = \"Sample Size\", x = \"Expected coverage proportion\") +\r\n      ggplot2::theme_minimal() + ggplot2::theme(legend.position=\"bottom\")\r\n  })\r\n  output$plot = renderPlot({\r\n    dat = getOutputUsingFun(\"dOutput\",input,expandForPlot=\"n\",x_gran=x_gran)\r\n    dat$p = as.factor(dat$p)\r\n    ggplot2::ggplot(dat, ggplot2::aes(x = n, y = d, color = interaction(p,m,icc,cv,r,alpha), group = interaction(p,m,icc,cv,r,alpha))) +\r\n      ggplot2::geom_line(size = 1) + ggplot2::geom_point() + \r\n      ggplot2::labs(title = \"CI Half-Width as a function of Sample Size\", x = \"Sample Size\", y = \"CI Half-Width\") +\r\n      ggplot2::theme_minimal() + ggplot2::theme(legend.position=\"bottom\")\r\n  })\r\n  \r\n  \r\n  output$statement_message = renderText({\r\n    if(input$study_type==\"Estimation\" & input$calc_type == \"Sample size\"){\r\n      v = output_table()[1,]\r\n      val = paste0(\"\r\n        Using the first row of the table as an example:\\n\r\n        With an expected coverage proportion of \",v$p,\",\r\n        a desired half-width CI of \",v$d,\", \r\n        and a Type I error rate of \",v$alpha,\", \r\n        the effective sample size is \",v$ess,\".\\n\r\n        With an intracluster correlation coefficient of \",v$icc,\", \r\n        a coefficient of variation of sample weights of \",v$cv,\",\r\n        and setting the target number of respondents per cluster at \",v$m,\" \r\n        results in a design effect of \",v$deff,\".\\n\r\n        With this effective sample size, design effect and an anticipated non-response rate of \",v$r,\"\r\n        we have a required sample size of \",v[\"n(ess,deff,inf)\"],\".\\n\r\n        Combining sample size cluster size, we see we need \",v$nc,\" clusters.\"\r\n      )\r\n    }\r\n    if(input$study_type==\"Estimation\" & input$calc_type == \"Half-width CI\"){\r\n      v = output_table()[1,]\r\n      val = paste0(\"\r\n        Using the first row of the table as an example:\\n\r\n        Having an expected coverage proportion of \",v$p,\",\r\n        a target number of respondents per cluster of \",v$m,\", \r\n        an intracluster correlation coefficient of \",v$icc,\", \r\n        a coefficient of variation of sample weights of \",v$cv,\",\r\n        an anticipated non-response rate of \",v$r,\",\r\n        a Type I error rate of \",v$alpha,\", \r\n        and setting the study's sample size at \",v$n,\" \r\n        results in a half-width CI of \",v$d\r\n      )\r\n    }\r\n    val\r\n  })\r\n  \r\n  output$R_print = renderText({\"hello\"})\r\n  \r\n  # Download\r\n  EstSSOutTab = reactive({makeOutputTable(input)})\r\n\t\r\n  output$ESSdfDownload = downloadHandler(\r\n    filename = \"sample_size.csv\",\r\n    content = function(file){write.csv(EstSSOutTab(),file,row.names=FALSE)}\r\n  )\r\n\r\n\r\n  # Bookmark\r\n   observe({\r\n    reactiveValuesToList(input)\r\n    session$doBookmark()\r\n  })\r\n  onBookmarked(updateQueryString)\r\n  \r\n  \r\n}\r\n","type":"text"},{"name":"ui.R","content":"# GitHub: https://github.com/CDCgov/Study_Design_Tools_for_Complex_Cluster_Surveys\r\n# App: https://cdcgov.github.io/Study_Design_Tools_for_Complex_Cluster_Surveys/\r\n#\r\n# UI for Shinylive app\r\n# Contents:\r\n#   UI Diagram\r\n#   Functions to instantiate inputs, other misc. code\r\n#   ui object for app\r\n# \r\n# UI Diagram:\r\n# ui\r\n#   fluidPage\r\n#     fluidRow \"Top Row\"\r\n#       sidebarLayout\r\n#         sidebarPanel \"Left\"\r\n#           tabsetPanel \"Study Type\"\r\n#             tabPanel \"Estimation\"\r\n#               conditionalPanel \"Sample size\"\r\n#               conditionalPanel \"Half-width CI\"\r\n#             tabPanel \"Classification\"\r\n#             tabPanel \"Comparison\"\r\n#               conditionalPanel \"2 Group, 2-Sided\"\r\n#               conditionalPanel \"1 Group, 1-Sided\"\r\n#         mainPanel \"Right\"\r\n#           tabsetPanel \"Output Type\"\r\n#             tabPanel \"Table\"\r\n#             tabPanel \"Plots\"\r\n#               conditionalPanel \"Sample size\"\r\n#               conditionalPanel \"Half-width CI\"\r\n#             tabPanel \"Statement\"\r\n#             tabPanel \"R\"\r\n#     fluidRow \"Bottom Row (footer)\"\r\n\r\n\r\n# Workaround for Shinylive Issue 468227\r\ndownloadButton = function(...) {\r\n  tag = shiny::downloadButton(...)\r\n  tag$attribs$download = NULL\r\n  tag\r\n}\r\n\r\n# Objects to instantiate inputs\r\n\r\nbuildInputControlFor = function(fun_name){\r\n  meta = eval(parse(text=paste0(\".\",fun_name,\".meta\")))\r\n  f = function(x){\r\n    type = x$input_control_type\r\n    args = x$input_control_args\r\n    args$label = paste0(args$inputId,\": \",args$label)\r\n    args$inputId = paste0(fun_name,\"_\",args$inputId)\r\n    aschArgs = as.character(args)\r\n    ii = sapply(args,length)==1 & !sapply(args,is.logical)\r\n    aschArgs[ii] = paste0(\"'\",aschArgs[ii],\"'\")\r\n    val = paste0(type,paste0(\"(\",paste(paste(names(args),aschArgs,sep=\"=\"),collapse=\" , \"),\")\"))\r\n    eval(parse(text=val))\r\n  }\r\n  lapply(meta,f)\r\n}\r\n\r\nsource(\"ui_input_controls_info.R\")\r\nic_nOutTab = buildInputControlFor(\"nOutTab\")\r\nic_dOutput = buildInputControlFor(\"dOutput\")\r\nic_nclOutTab = buildInputControlFor(\"nclOutTab\")\r\nic_ESS_2Grp_2Sided = buildInputControlFor(\"ESS_2Grp_2Sided\")\r\nic_ESS_1Grp_1Sided = buildInputControlFor(\"ESS_1Grp_1Sided\")\r\n\r\n# selectInput()s for choosing calculation type\r\nin_calc_type = function()selectInput(\"calc_type\",\"Solve for:\",c(\"Sample size\",\"Half-width CI\"))\r\nin_calc_typeCo = function()selectInput(\"calc_type_Com\",\"Study sub-type:\",c(\"2 Group, 2-Sided\",\"1 Group, 1-Sided\"))\r\n\r\n\r\n\r\nui = function(request){\r\n  fluidPage(\r\n    fluidRow( #fluidRow main\r\n      title = \"Cluster Survey Sample Size\",\r\n      shinyFeedback::useShinyFeedback(),\r\n      titlePanel(\"Cluster Survey Sample Size\"),\r\n      sidebarLayout(\r\n        sidebarPanel(\r\n          p(\"Select a Study Type:\"),\r\n          tabsetPanel(\r\n            id=\"study_type\",\r\n            helpText(\"Enter comma-separated values and select from drop-down menus\"),\r\n            # Estimation\r\n            tabPanel(\r\n              \"Estimation\",\r\n              condition = \"input.study_type == 'Estimation'\",\r\n              in_calc_type(),\r\n              conditionalPanel(\r\n                condition = \"input.calc_type == 'Sample size'\",\r\n                ic_nOutTab$d,\r\n                ic_nOutTab$p,\r\n                ic_nOutTab$alpha,\r\n                ic_nOutTab$m,\r\n                ic_nOutTab$icc,\r\n                ic_nOutTab$cv,\r\n                ic_nOutTab$r\r\n              ),\r\n              conditionalPanel(\r\n                condition = \"input.calc_type == 'Half-width CI'\",\r\n                ic_dOutput$n,\r\n                ic_dOutput$p,\r\n                ic_dOutput$alpha,\r\n                ic_dOutput$m,\r\n                ic_dOutput$icc,\r\n                ic_dOutput$cv,\r\n                ic_dOutput$r\r\n              )\r\n            ),\r\n            # Classification\r\n            tabPanel(\r\n              \"Classification\",\r\n              condition = \"input.study_type == 'Classification'\",\r\n              ic_nclOutTab$P0,\r\n              ic_nclOutTab$delta,\r\n              ic_nclOutTab$direction,\r\n              ic_nclOutTab$alpha,\r\n              ic_nclOutTab$beta,\r\n              ic_nclOutTab$m,\r\n              ic_nclOutTab$icc,\r\n              ic_nclOutTab$cv,\r\n              ic_nclOutTab$r\r\n            ),\r\n            # Comparison\r\n            tabPanel(\r\n              \"Comparison\",\r\n              condition = \"input.study_type == 'Comparison'\",\r\n              in_calc_typeCo(),\r\n              conditionalPanel(\r\n                condition = \"input.calc_type_Com == '2 Group, 2-Sided'\",\r\n                ic_ESS_2Grp_2Sided$P1,\r\n                ic_ESS_2Grp_2Sided$Delta,\r\n                ic_ESS_2Grp_2Sided$Alpha,\r\n                ic_ESS_2Grp_2Sided$Beta,\r\n                ic_ESS_2Grp_2Sided$SS_ratio\r\n              ),\r\n              conditionalPanel(\r\n                condition = \"input.calc_type_Com == '1 Group, 1-Sided'\",\r\n                ic_ESS_1Grp_1Sided$P1,\r\n                ic_ESS_1Grp_1Sided$P2,\r\n                ic_ESS_1Grp_1Sided$Alpha,\r\n                ic_ESS_1Grp_1Sided$Beta,\r\n                ic_ESS_1Grp_1Sided$ESS1\r\n              ),\r\n            )\r\n          )\r\n        ),\r\n        # Main panel\r\n        mainPanel(\r\n          tabsetPanel(\r\n            tabPanel(\r\n              \"Table\",\r\n              verbatimTextOutput(\"dev\"),\r\n              # Bookmark feature not currently supported in Shinylive\r\n              #fluidRow(downloadButton(\"ESSdfDownload\",\"Download\"), bookmarkButton()),\r\n              fluidRow(downloadButton(\"ESSdfDownload\",\"Download\")),\r\n              fluidRow(tableOutput(\"ESSdf\"))\r\n            ),\r\n            tabPanel(\r\n              \"Plots\",\r\n              conditionalPanel(\r\n                condition = \"input.calc_type == 'Sample size'\",\r\n                plotOutput(\"plot1\"),\r\n                plotOutput(\"plot2\")\r\n              ),\r\n              conditionalPanel(\r\n                condition = \"input.calc_type == 'Half-width CI'\",\r\n                plotOutput(\"plot\")\r\n              )\r\n            ),\r\n            tabPanel(\r\n              \"Statement\",\r\n              verbatimTextOutput(\"statement_message\")\r\n            ),\r\n            tabPanel(\r\n              \"R\",\r\n              verbatimTextOutput(\"R_print\")\r\n            )          \r\n          )\r\n        )\r\n      )\r\n    ),# fluidRow main\r\n    fluidRow( # fluidRow footer \r\n      p(\"footer\")\r\n    ) # fluidRow footer\r\n  )\r\n}\r\n\r\n","type":"text"},{"name":"Compile_Shinylive_App.R","content":"\r\n\r\n# Required:\r\n#   shiny\r\n#   shinyFeedback\r\n#   bslib\r\n#   ggplot2\r\n#   munsell\r\n#   this.path (only if you're setting wd using source as below)\r\n# Print message if any are not installed:\r\nrequired_packages = c(\"shiny\",\"shinyFeedback\",\"bslib\",\"ggplot2\",\"munsell\",\"this.path\")\r\nhave_packages = required_packages %in% installed.packages()\r\nif(!all(have_packages)){\r\n  print(\"Please install the following package(s):\")\r\n  required_packages[!have_packages]\r\n}\r\n\r\n\r\n# A file with a single line: setwd(path),\r\n# where path is \"root_of_repo/R\"\r\nsource(paste0(this.path::here(),\"/\",\"setWD.R\"))\r\n\r\n\r\n# Check that it runs properly on local machine\r\nshiny::runApp()\r\n\r\n# Compile into serverless web app\r\nshinylive::export(appdir = getwd(), destdir = \"../docs\")\r\n\r\n# Check that the serverless web app works properly\r\nhttpuv::runStaticServer(\"../docs\")\r\n\r\n","type":"text"},{"name":"Sample size 2 group design.R","content":"  \r\n################################################################################\r\n#                         Part 1(Table B-4):\r\n# Testing for differences in vaccination coverage between places or subgroups, \r\n# or between two future surveys\r\n# \r\n# Null hypothesis(Ho): Coverages is the same in the two places/groups  \r\n# Alternative Hypothesis(Ha): Coverage differs in the two places/groups \r\n################################################################################\r\n# Parameters for function ESS_2Grp_2sided \r\n# P1: the estimated coverage level from one of the two surveys\r\n# Delta: the difference above P1 form which the survey should be well\r\n#        powered to reject the null hypothesis                                 \r\n# Alpha: type 1 error, reject null when null is true, claim there is difference \r\n#        when in fact there isn't, default=0.05\r\n# Beta:  type 2 error, fail to reject null when null is false, claim there is \r\n#        no differece in coverage when in fact there is, default=0.20\r\n# SS_ratio: sample size ratio between two groups\r\n#          (i.e., how many times SS in group2 over group 1),default=1.0\r\n################################################################################\r\n\r\nESS_2Grp_2Sided<-function(P1, Delta, Alpha=0.05, Beta=0.20,SS_ratio=1.0){\r\n#Exception handling:check the input parameters, print the error message and exit the function\r\n  if((P1<0|P1>1 )|(Delta<0|Delta>1)|(Alpha<0|Alpha>1)|(Beta<0|Beta>1)|SS_ratio<0)\r\n  stop(\"P1, Delta, Alpha, Beta must be between 0 and 1, SS Ratio must be greater than 0\")  \r\n\r\n# Equation B3-1, n1 without continuity correction\r\n  P2=P1+Delta\r\n  P_hat=(P1+SS_ratio*(P1+Delta))/(SS_ratio+1.0)\r\n  n1_no_cc_numer=(qnorm(1-Alpha/2.0)*sqrt((SS_ratio+1)*P_hat*(1-P_hat))+\r\n                        qnorm(1-Beta)*sqrt(SS_ratio*P1*(1-P1)+P2*(1-P2)))**2\r\n  n1_no_cc_denom=SS_ratio*((P2-P1)**2)\r\n  n1_no_cc=n1_no_cc_numer/n1_no_cc_denom\r\n\r\n# Equation B3-2\r\n  n2_no_cc=SS_ratio*n1_no_cc\r\n\r\n#Equation B3-3\r\nn1_with_cc=(n1_no_cc/4.0)*(1.0+sqrt(1.0+(2*(SS_ratio+1))/(n1_no_cc*SS_ratio*abs(P2-P1))))**2\r\nn2_with_cc=SS_ratio*n1_with_cc  \r\n\r\n# Print out the results\r\n#print(\"###################################################\")\r\n#print(\"Input parameters\")\r\n#print(paste(\"P1=\", P1,\",\", \"Delta=\", Delta,\",\", \"P2=P1+Delta=\", P2,\",\",\r\n#          \"Alpha=\", Alpha,\",\", \"Beta=\", Beta))\r\n\r\nESS1=ceiling(n1_with_cc)\r\nESS2=ceiling(n2_with_cc)\r\n#print(\"###################################################\")\r\n#print(\"ESS for group 1(Table B-4):\")\r\n#print(ESS1)\r\n#print(\"Sample Size ratio(i.e.,how many times ESS in group 2 vs group 1):\")\r\n#print(SS_ratio)\r\n#print(\"ESS for group 2:\")\r\n#print(ESS2)\r\n#print(\"###################################################\")\r\n#Return ESS1 and ESS2 in the list, and can be retrieved for the other calculations \r\nreturn(list(ESS1,ESS2))\r\n}\r\n\r\n#ESS_2Grp_2Sided(0.5,0.10,0.10,0.2,1.1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n################################################################################\r\n#                         Part 2\r\n# Testing for an increase in coverage over time, when the earlier survey was \r\n# conducted in the past\r\n#  \r\n# Null hypothesis(Ho): p2<=p1, coverage for the planned survey is less or equal\r\n#                      than the previously conducted survey  \r\n# Alternative Hypothesis: p2>p1, coverage for the planned survey is greater than\r\n#                      the previous survey  \r\n################################################################################\r\n# Parameters for function ESS_2Grp_2sided \r\n# P1: coverage for the previously conducted survey\r\n# P2: coverage for the planned survey\r\n#        powered to reject the null hypothesis                                 \r\n# Alpha: type 1 error, reject null when null is true, claim there is coverage \r\n#        increase when in fact there isn't, default=0.05\r\n# Beta:  type 2 error, fail to reject null when null is false, claim there is \r\n#        no coverage increase when in fact there is, default=0.20\r\n# ESS1: Effective sample size from early conducted survey\r\n################################################################################\r\n\r\nESS_1Grp_1Sided<-function(P1, P2, Alpha=0.05, Beta=0.20,ESS1){\r\n  #Exception handling:check the input parameters, print the error message and exit the function\r\n  if((P1<0|P1>1 )|(P2<0|P2>1)|(Alpha<0|Alpha>1)|(Beta<0|Beta>1)|P2<P1)\r\n    stop(\"P1,P2, Delta, Alpha, Beta must be between 0 and 1, P1 must be less than P2\")  \r\n  \r\n  # Equation B3-7, n without continuity correction\r\n  P_hat=(P1+P2)/2\r\n  n_no_cc_numer=(qnorm(1-Alpha)*sqrt(2*P_hat*(1-P_hat))+\r\n                    qnorm(1-Beta)*sqrt(P1*(1-P1)+P2*(1-P2)))**2\r\n  n_no_cc_denom=(P2-P1)**2\r\n  n_no_cc=n_no_cc_numer/n_no_cc_denom\r\n  \r\n  \r\n  # Equation B3-8\r\n  \r\n  n_with_cc=(n_no_cc/4.0)*(1.0+sqrt(1.0+4/(n_no_cc*abs(P2-P1))))**2\r\n  \r\n  # Equation B3-9\r\n  SS_ratio=n_with_cc/(2*ESS1-n_with_cc)\r\n#  print (\"Sample Size Ratio=\")\r\n#  print(SS_ratio)\r\n  if(SS_ratio<0) stop(\"No positive sample size ratio exists and the study as planned should be abandoned\")\r\n  \r\n  # Equation B3-10\r\n  if(SS_ratio>0) n2_with_cc=SS_ratio*ESS1\r\n  \r\n  # Print out the results\r\n# print(\"###################################################\")\r\n# print(\"Input parameters\")\r\n# print(paste(\"P1=\", P1,\",\", \"p2=\", P2,\",\",\"Alpha=\", Alpha,\",\", \"Beta=\", \r\n#             Beta,\",\", \"ESS1=\", ESS1))\r\n# \r\n  ESS2=ceiling(n2_with_cc)\r\n  \r\n#  print(\"###################################################\")\r\n#  print(\"ESS for group 1:\")\r\n#  print(ESS1)\r\n#  print(\"Sample Size ratio(i.e.,how many times ESS in group 2 vs known sample size in group 1):\")\r\n#  print(SS_ratio)\r\n#  print(\"ESS for group 2:\")\r\n#  print(ESS2)\r\n#  print(\"###################################################\")\r\n  #Return ESS2  \r\n  return(ESS2)\r\n}\r\n\r\n#ESS_1Grp_1Sided(0.7,0.8,0.05,0.2,174)\r\n\r\n","type":"text"},{"name":"_run_Classification.R","content":"## rm(list=ls());gc()\r\n\r\n#\r\n# R code\r\n# Implements functionalities for study design from:\r\n#   Vaccination Coverage Cluster Surveys: Reference Manual. \r\n#   Geneva: World Health Organization; 2018 (WHO/IVB/18.09). \r\n#   Licence: CC BY-NC-SA 3.0 IGO.\r\n#   Ordering code: WHO/IVB/18.09\r\n#\r\n# Page numbers refer to this document\r\n#\r\n# Terms and Parameters used:\r\n#   Delta = [ ... will include code to calculate this for given n ...]\r\n#\r\n#   ESScl = Effective Sample Size; p.131\r\n#     ESScl(P0, delta, alpha, beta, direction)\r\n#     P0 = the programmatic threshold\r\n#     delta = a coverage percent defining a distance from P0\r\n#     alpha = Type I error\r\n#     beta = Type II error\r\n#   DEFF = Design Effect; p.110\r\n#     DE(m,icc,cv)\r\n#     m = target number of respondents per cluster; p.109\r\n#     icc = intracluster correlation coefficient; p.109\r\n#     cv = coefficient of variation of sample weights\r\n#   INF = Inflation factor to account for non-response; p.112, 128\r\n#     INF(r)\r\n#     r = anticipated non-response rate, from 0 to 1\r\n#\r\n# Outline:\r\n#   * Computation functions\r\n#   * Validation of computation functions\r\n#   * Output functions\r\n#   * Example usage\r\n#\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Setup\r\n#\r\n\r\n# set working directory as git repo root\r\nsetwd(\"C:/Users/JNN6/OneDrive - CDC/GitHub/cluster_survey_sample_size\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Computation functions\r\n#\r\n# ESScl(P0, delta, alpha, beta, direction)\r\n# DE(m,icc=1/6,cv=0.05)\r\n# INF(r)\r\n# halfWidthCI(n,p,m,icc,cv,r,alpha=0.05)\r\n\r\nsource(\"R/functions.R\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Validation of computation functions\r\n#\r\n\r\nsource(\"R/validation.R\")\r\n\r\n# Recreate Tables B-2 p.123 & B-3 p. 125 to validate ESScl\r\n# (d,p)\r\nTab_B_2\r\nTab_B_3\r\n\r\n# delta calculated as a function of n, P0, alpha, beta, direction\r\ndeltaTab\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Output functions\r\n#\r\n# nclOutTab(P0,delta,alpha,beta,direction,m,icc,cv,r)\r\n\r\nsource(\"R/output.R\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Example usage\r\n#\r\n\r\n# Some example inputs\r\np = c(.7,.8)\r\nd = c(.01,.05)\r\na = c(.1,.05)\r\nb = c(.2,.1)\r\nm = c(5,15)\r\nicc = c(1/22,1/6)\r\ncv = c(0.50)\r\nr = c(15)/100\r\n\r\n# Compute sample size required for various inputs\r\nexTab = nclOutTab(p,d,a,b,'below',m,icc,cv,r)[[1]]\r\n\r\n# Compute delta for given n and everything else\r\nexTab$deltaGot = apply(exTab,1,function(x)\r\n  getDelta(x[12],x[1],x[3],x[4],'below',x[5],x[6],x[7],x[8])\r\n)\r\nexTab\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# n = c(7000,500)\r\n# P0 = c(.7,.8)\r\n# alpha = c(.1)\r\n# beta = c(.2)\r\n# direction = 'below'\r\n# m = c(5)\r\n# icc = c(1/22)\r\n# cv = c(0.50)\r\n# r = c(15)/100\r\n# #n = c(9363,7418,411,328,13165,10115,554,438,\r\n# #        14024,10804,595,476,18230,14023,766,609)\r\n# \r\n# \r\n# \r\n# # Find delta given n (and everything else)\r\n# #\r\n# deltaOutput = function(n, P0, alpha, beta, direction, m, icc, cv, r){\r\n#   val=expand.grid(n,P0,alpha,beta,m,icc,cv,r)\r\n#   colnames(val) = c(\"n\",\"P0\",\"alpha\",\"beta\",\"m\",\"icc\",\"cv\",\"r\")\r\n#   val$delta = apply(val,1,function(x)\r\n#       getDelta(x[1],x[2],x[3],x[4],direction,x[5],x[6],x[7],x[8])\r\n#     )\r\n#   val\r\n# } \r\n# \r\n# \r\n# \r\n# deltaOutput(n,P0,alpha,beta,'below',m,icc,cv,r)\r\n#val$direction = as.character(val$direction)\r\n#val = val[!(val$direction=='below' & val$P0-val$delta<0),]\r\n#val = val[!(val$direction=='above' & val$P0+val$delta>1),]\r\n","type":"text"},{"name":"_run_Estimation.R","content":"## rm(list=ls());gc()\r\n\r\n#\r\n# R code\r\n# Implements functionalities for study design from:\r\n#   Vaccination Coverage Cluster Surveys: Reference Manual. \r\n#   Geneva: World Health Organization; 2018 (WHO/IVB/18.09). \r\n#   Licence: CC BY-NC-SA 3.0 IGO.\r\n#   Ordering code: WHO/IVB/18.09\r\n#\r\n# Page numbers refer to this document\r\n#\r\n# Terms and Parameters used:\r\n#   CI = Confidence Interval\r\n#     halfWidthCI(n,p,m,icc,cv,r,alpha)\r\n#       finds the half-width CI (d) for a given sample size and design\r\n#     n = sample size\r\n#     all other terms defined below\r\n#   ESS = Effective Sample Size; p.129\r\n#     ESS(p,d,alpha)\r\n#     p = expected coverage proportion\r\n#     d = desired half-width of the CI\r\n#     alpha = the probability value used to define the precision for \r\n#             estimated CIs; usually 0.05 for 95% CI\r\n#   DEFF = Design Effect; p.110\r\n#     DE(m,icc,cv)\r\n#     m = target number of respondents per cluster; p.109\r\n#     icc = intracluster correlation coefficient; p.109\r\n#     cv = coefficient of variation of sample weights\r\n#   INF = Inflation factor to account for non-response; p.112, 128\r\n#     INF(r)\r\n#     r = anticipated non-response rate, from 0 to 1\r\n#\r\n# Outline:\r\n#   * Computation functions\r\n#   * Validation of computation functions\r\n#   * Output functions\r\n#   * Example usage\r\n#\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Setup\r\n#\r\n\r\n# set working directory as git repo root\r\nsetwd(\"C:/Users/JNN6/OneDrive - CDC/GitHub/cluster_survey_sample_size\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Computation functions\r\n#\r\n# ESS(p,d,alpha=0.05)\r\n# DE(m,icc=1/6,cv=0.05)\r\n# INF(r)\r\n# halfWidthCI(n,p,m,icc,cv,r,alpha=0.05)\r\n\r\nsource(\"R/functions.R\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Validation of computation functions\r\n#\r\n\r\nsource(\"R/validation.R\")\r\n\r\n# Recreate Table B-1 p.118 to validate ESS\r\n# (d,p)\r\nTab_B_1\r\n\r\n\r\n# d calculated as a function of n & p\r\n# (n,p)\r\nround(dTab,2)\r\n\r\n# Do the calculated d give back the correct n?\r\n# (n,p)\r\nround(ndTab,1)\r\n\r\n# Close ... what's the difference?\r\nround(ndTab,1)-nLst\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Output functions\r\n#\r\n# nOutTab(p,d,m,icc,cv,r,alpha)\r\n# dOutTab(n,p,m,icc,cv,r,alpha)\r\n\r\nsource(\"R/output.R\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Example usage\r\n#\r\n\r\n# Some example inputs\r\nn = c(300,900)\r\nd = c(5,10)/100\r\np = c(0.10,0.25)\r\nm = c(5,15)\r\nicc = c(1/22,1/6)\r\ncv = c(0.50)\r\nr = c(15)/100\r\nalpha = c(0.05)\r\n\r\n# Compute sample size required for various inputs\r\nnOutTab(d,p,m,icc,cv,r,alpha)\r\n\r\n# Compute study's half-width CI for various sample sizes & other inputs\r\ndOutput(n,p,m,icc,cv,r,alpha)\r\n\r\n\r\n\r\n# Some example inputs\r\nn = seq(100,1000,by=100)\r\np = c(0.05,0.25)\r\nm = 15\r\nicc = 1/6\r\ncv = 0.50\r\nr = 15/100\r\nalpha = 0.05\r\n\r\n# Examine how d changes for varying n\r\ndPlot = outer(n,p,Vectorize(halfWidthCI),m,icc,cv,r)\r\nplot(n,dPlot[,1],type='l')\r\nlines(n,dPlot[,2],col='red')\r\n\r\n# See how well d was computed (or not)\r\nsapply(dPlot,function(x)ESS(0.05,x)* DE(m,icc,cv)*INF(r))\r\n\r\n\r\n","type":"text"},{"name":"functions.R","content":"\r\n\r\n\r\n#\r\n# Estimation\r\n#\r\n\r\n# ESS Effective Sample Size eq. B2-1 for ESS p.129\r\nESS = function(p,d,alpha=0.05){\r\n  if(p<0|p>1)stop(\"p must be a number from 0 to 1\")\r\n  if(d<=0|d>=0.3)stop(\"d must be a number between 0 and 0.3\")\r\n  if(alpha<=0|alpha>=1)stop(\"alpha must be a number between 0 and 1\")\r\n  # Calculate k according to Table K on p.129\r\n  k=1\r\n  if(p<d|p>1-d)k=8*d*(1-2*d)\r\n  if(p>=d&p<0.3)k=4*(p+d)*(1-p-d)\r\n  if(p>0.7&p<=1-d)k=4*(p-d)*(1-p+d)\r\n  z=qnorm(1-alpha/2)\r\n  ceiling(k*z^2/4/d^2 + 1/d - 2*z^2 + (z+2)/k)\r\n}\r\n\r\n\r\n# Solve for d for given n, p, m, icc, cv, r, alpha\r\nhalfWidthCI = function(n,p,m,icc,cv,r,alpha=0.05){\r\n  deff = DE(m,icc,cv)\r\n  inf = INF(r)\r\n  ess = n/deff/inf\r\n  z = qnorm(1-alpha/2)\r\n  \r\n  f = function(d,ess,p,z){\r\n    k=1\r\n    if(p<d|p>1-d)k=8*d*(1-2*d)\r\n    if(p>=d&p<0.3)k=4*(p+d)*(1-p-d)\r\n    if(p>0.7&p<=1-d)k=4*(p-d)*(1-p+d)\r\n    (  ess - (k*z^2/4/d^2 + 1/d - 2*z^2 + (z+2)/k)  )^2\r\n  }\r\n  optimize(f,c(0,1),ess=ess,p=p,z=z)$minimum\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Classification\r\n#\r\n\r\n# ESS Effective Sample Size for classification eq. B2-3 p.131\r\nESScl = function(P0, delta, alpha, beta, direction){\r\n  if(P0<0|P0>1)stop(\"P0 must be a number from 0 to 1\")\r\n  if(alpha<=0|alpha>=1|beta<=0|beta>=1)stop(\"alpha & beta must be a number between 0 and 1\")\r\n  direction = tolower(direction)\r\n  if(!direction %in% c('above','below'))stop(\"direction must be either 'above' or 'below' (case-insensitive)\")\r\n  if(direction=='above' & P0+delta>1)stop(\"P0+delta>1\")\r\n  if(direction=='below' & P0-delta<0)stop(\"P0-delta<0\")\r\n  if (direction=='above') {P1=P0+delta} else {P1=P0-delta}\r\n  z1=qnorm(1-alpha)\r\n  z2=qnorm(1-beta)  \r\n  n_0 = ((z1*sqrt(P0*(1-P0))+z2*sqrt(P1*(1-P1)))/(P1-P0))**2\r\n  ceiling((n_0/4)*(1+sqrt(1+2/(n_0*abs(delta))))**2)\r\n}\r\n\r\n\r\n# Solve for delta for given n, P0, alpha, beta, direction, m, icc, cv, r\r\ngetDelta = function(n, P0, alpha, beta, direction, m, icc, cv, r){\r\n  dir = tolower(direction)\r\n  deff = DE(m,icc,cv)\r\n  inf = INF(r)\r\n  ess = n/deff/inf\r\n  z1=qnorm(1-alpha)\r\n  z2=qnorm(1-beta)  \r\n  \r\n  f = function(delta,ess,P0,z1,z2){\r\n    if (dir=='above') {P1=P0+delta} else {P1=P0-delta}\r\n    n_0 = ((z1*sqrt(P0*(1-P0))+z2*sqrt(P1*(1-P1)))/(P1-P0))**2\r\n    x = (n_0/4)*(1+sqrt(1+2/(n_0*abs(delta))))**2\r\n    (ess-x)**2\r\n  }\r\n  optimize(f,c(0,1),ess=ess,P0=P0,z1=z1,z2=z2)$minimum\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# General\r\n#\r\n\r\n\r\n# DEFF Design Effect p.110 equation for DEFF\r\nDE = function(m,icc=1/6,cv=0.50){\r\n (1+(m-1)*icc)*(1+cv^2)\r\n}\r\n\r\n\r\n# Inflation factor due to non-response; p.112\r\n# Note: r %in% (0,1)\r\nINF = function(r)1/(1-r)\r\n\r\n\r\n\r\n\r\n","type":"text"},{"name":"output.R","content":"\r\n\r\n#\r\n# Estimation\r\n#\r\n\r\n# Each input can be a single number or a list of numbers.\r\n# Note that a data.frame is output with number of rows equal to\r\n#   the product of the lengths of the input lists ... so it can get\r\n#   large quickly.\r\n\r\n# Make a table of sample sizes.\r\n# Output columns:\r\n#  ess(p,d,alpha) Effective Sample Sizes\r\n#  deff(m,icc,cv) Design Effect \r\n#  inf(f) Inflation Factor\r\n#  n(ess,deff,inf) Sample Size\r\n#  nc(n,m) Number of Clusters\r\nnOutTab = function(d,p,m,icc=1/6,cv=0.50,r,alpha=0.05){\r\n  val=expand.grid(p,d,alpha,m,icc,cv,r)\r\n  colnames(val) = c(\"p\",\"d\",\"alpha\",\"m\",\"icc\",\"cv\",\"r\")\r\n  val$ess=apply(val[,c(\"d\",\"p\",\"alpha\")],1,function(x)ESS(x[2],x[1],x[3]))\r\n  val$deff=DE(val$m,icc=val$icc,cv=val$cv)\r\n  val$inf=INF(val$r)\r\n  val$n = ceiling(val$ess * val$deff * val$inf)\r\n  val$nc = ceiling(val$n / val$m)\r\n  colnames(val) = c(\r\n    \"p\",\"d\",\"alpha\",\"m\",\"icc\",\"cv\",\"r\",\r\n    \"ess(p,d,alpha)\",\"deff(m,icc,cv)\",\"inf(r)\",\"n(ess,deff,inf)\",\r\n    \"nc(n,m)\"\r\n  )\r\n  val\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Find half-width of CI given n (and everything else)\r\n#\r\ndOutput = function(n,p,m,icc=1/6,cv=0.50,r,alpha=0.05){\r\n  val=expand.grid(n,p,m,icc,cv,r,alpha)\r\n  colnames(val) = c(\"n\",\"p\",\"m\",\"icc\",\"cv\",\"r\",\"alpha\")\r\n  val$d = apply(val,1,function(x)\r\n      halfWidthCI(x[1],x[2],x[3],x[4],x[5],x[6],x[7])\r\n    )\r\n  val\r\n} \r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Classification\r\n#\r\n\r\nnclOutTab = function(P0,delta,alpha,beta,direction,m,icc,cv,r){\r\n  direction = tolower(direction)\r\n  # Only do either above or below but not both in the same table\r\n  if(!direction %in% c('above','below'))stop(\"direction must be either 'above' or 'below' (case-insensitive). This function only allows for creating an output table for one or the other 'above' or 'below' but not both.\")\r\n  val=expand.grid(P0,delta,alpha,beta,m,icc,cv,r)\r\n  colnames(val) = c(\"P0\",\"delta\",\"alpha\",\"beta\",\"m\",\"icc\",\"cv\",\"r\")\r\n  val$ess=apply(val[,c(\"P0\",\"delta\",\"alpha\",\"beta\")],1,function(x)ESScl(x[1],x[2],x[3],x[4],direction))\r\n  val$deff=DE(val$m,icc=val$icc,cv=val$cv)\r\n  val$inf=INF(val$r)\r\n  val$n = ceiling(val$ess * val$deff * val$inf)\r\n  val$nc = ceiling(val$n / val$m)\r\n  colnames(val) = c(\r\n    \"P0\",\"delta\",\"alpha\",\"beta\",\"m\",\"icc\",\"cv\",\"r\",\r\n    \"ess(P0,delta,alpha,beta,direction)\",\"deff(m,icc,cv)\",\"inf(r)\",\r\n    \"n(ess,deff,inf)\",\"nc(n,m)\"\r\n  )\r\n  list(Table=val, direction=direction)\r\n}","type":"text"},{"name":"setWD.R","content":"\r\n\r\nsetwd(\"C:/GitHub/Study_Design_Tools_for_Complex_Cluster_Surveys/R\")\r\n\r\n","type":"text"},{"name":"ui_input_controls_info.R","content":"\r\n\r\n\r\n\r\n.DE.meta = list(\r\n  m = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"m\",\r\n      label = \"Target number of respondents per cluster\",\r\n      value = \"5, 15\"\r\n    )\r\n  )\r\n  ,\r\n  icc = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"icc\",\r\n      label = \"Intracluster correlation coefficient\",\r\n      value = \"1/22, 1/6\"\r\n    )\r\n  )\r\n  ,\r\n  cv = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"cv\",\r\n      label = \"Coefficient of variation of sample weights\",\r\n      value = \"0.50\"\r\n    )\r\n  )\r\n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.INF.meta = list(\r\n  r = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"r\",\r\n      label = \"Anticipated non-response rate, from 0 to 1\",\r\n      value = \"0.15\"\r\n    )\r\n  )\r\n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.nOutTab.meta = list(\r\n  d = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"d\",\r\n      label = \"Desired half-width CI\",\r\n      value = \"0.05, 0.10\"\r\n    )\r\n  )\r\n  ,\r\n  p = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"p\",\r\n      label = \"Expected coverage proportion\",\r\n      value = \"0.10, 0.25\"\r\n    )\r\n  )\r\n  ,\r\n  alpha = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"alpha\",\r\n      label = \"Type I error rate\",\r\n      choices = c(\"0.01\",\"0.025\",\"0.05\",\"0.10\"),\r\n      selected = \"0.05\",\r\n      multiple = TRUE\r\n    )\r\n  )\r\n)\r\n.nOutTab.meta = c(.nOutTab.meta,.DE.meta,.INF.meta)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.dOutput.meta = list(\r\n  n = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"n\",\r\n      label = \"Sample size\",\r\n      value = \"300, 900\"\r\n    )\r\n  )\r\n  ,\r\n  p = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"p\",\r\n      label = \"Expected coverage proportion\",\r\n      value = \"0.10, 0.25\"\r\n    )\r\n  )\r\n  ,\r\n  alpha = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"alpha\",\r\n      label = \"Type I error rate\",\r\n      choices = c(\"0.01\",\"0.025\",\"0.05\",\"0.10\"),\r\n      selected = \"0.05\",\r\n      multiple = TRUE\r\n    )\r\n  )\r\n)\r\n.dOutput.meta = c(.dOutput.meta,.DE.meta,.INF.meta)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.nclOutTab.meta = list(\r\n  P0 = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"P0\",\r\n      label = \"Programmatic threshold\",\r\n      value = \"0.7, 0.8\"\r\n    )\r\n  )\r\n  ,\r\n  delta = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"delta\",\r\n      label = \"A coverage percent defining a distance from P0\", \r\n      value = \"0.01, 0.05\"\r\n    )\r\n  )\r\n  ,\r\n  direction = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"direction\",\r\n      label = \"Direction\",\r\n      choices = c(\"below\",\"above\"),\r\n      selected = \"below\",\r\n      multiple = FALSE\r\n    )\r\n  )\r\n  ,\r\n  alpha = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"alpha\",\r\n      label = \"Type I error rate\",\r\n      choices = c(\"0.01\",\"0.025\",\"0.05\",\"0.10\"),\r\n      selected = c(\"0.01\",\"0.05\"),\r\n      multiple = TRUE\r\n    )\r\n  )\r\n  ,\r\n  beta = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"beta\",\r\n      label = \"Type II error rate\",\r\n      choices = c(\"0.10\",\"0.20\"),\r\n      selected = c(\"0.10\",\"0.20\"),\r\n      multiple = TRUE\r\n    )\r\n  )\r\n)\r\n.nclOutTab.meta = c(.nclOutTab.meta,.DE.meta,.INF.meta)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.ESS_2Grp_2Sided.meta = list(\r\n  P1 = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"P1\",\r\n      label = \"Estimated coverage level from one of the two surveys\",\r\n      value = \"0.5\"\r\n    )\r\n  )\r\n  ,\r\n  Delta = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"Delta\",\r\n      label = \"difference above P1 form which the survey should be well powered to reject the null hypothesis\", \r\n      value = \"0.10\"\r\n    )\r\n  )\r\n  ,\r\n  SS_ratio = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"SS_ratio\",\r\n      label = \"Sample size ratio between two groups n2:n1\",\r\n      value = \"1.1\"\r\n    )\r\n  )\r\n  ,\r\n  Alpha = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"Alpha\",\r\n      label = \"Type I error rate\",\r\n      choices = c(\"0.01\",\"0.025\",\"0.05\",\"0.10\"),\r\n      selected = c(\"0.10\"),\r\n      multiple = TRUE\r\n    )\r\n  )\r\n  ,\r\n  Beta = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"Beta\",\r\n      label = \"Type II error rate\",\r\n      choices = c(\"0.10\",\"0.20\"),\r\n      selected = c(\"0.20\"),\r\n      multiple = TRUE\r\n    )\r\n  )\r\n)\r\n.ESS_2Grp_2Sided.meta = c(.ESS_2Grp_2Sided.meta,.DE.meta,.INF.meta)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.ESS_1Grp_1Sided.meta = list(\r\n  P1 = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"P1\",\r\n      label = \"Coverage for the previously conducted survey\",\r\n      value = \"0.7\"\r\n    )\r\n  )\r\n  ,\r\n  P2 = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"P2\",\r\n      label = \"Coverage for the planned survey\",\r\n      value = \"0.8\"\r\n    )\r\n  )\r\n  ,\r\n  ESS1 = list(\r\n    input_control_type = \"textInput\",\r\n    input_control_args = list(\r\n      inputId = \"ESS1\",\r\n      label = \"Effective sample size from early conducted survey\",\r\n      value = \"174\"\r\n    )\r\n  )\r\n  ,\r\n  Alpha = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"Alpha\",\r\n      label = \"Type I error rate\",\r\n      choices = c(\"0.01\",\"0.025\",\"0.05\",\"0.10\"),\r\n      selected = c(\"0.05\"),\r\n      multiple = TRUE\r\n    )\r\n  )\r\n  ,\r\n  Beta = list(\r\n    input_control_type = \"selectInput\",\r\n    input_control_args = list(\r\n      inputId = \"Beta\",\r\n      label = \"Type II error rate\",\r\n      choices = c(\"0.10\",\"0.20\"),\r\n      selected = c(\"0.20\"),\r\n      multiple = TRUE\r\n    )\r\n  )\r\n)\r\n#.ESS_1Grp_1Sided.meta = c(.ESS_1Grp_1Sided.meta,.DE.meta,.INF.meta)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","type":"text"},{"name":"validation.R","content":"\r\n\r\n#\r\n# Estimation\r\n#\r\n\r\ndLst = seq(0.03,0.10,by=0.01)\r\npLst = c(seq(0.05,0.25,by=0.05),0.50,seq(0.75,0.95,by=0.05))\r\nnLst = seq(100,1000,by=100)\r\n\r\nm = 15\r\nicc = 1/6\r\ncv = 0.50\r\nr = 0.15\r\n\r\n# Make Table B-1 p.118 to validate ESS\r\nTab_B_1 = t(outer(pLst,dLst,Vectorize(ESS)))\r\ndimnames(Tab_B_1) = list(dLst,pLst)\r\nTab_B_1\r\n\r\n\r\n# Calculate d as a function of n & p\r\ndTab = outer(nLst,pLst,Vectorize(halfWidthCI),m,icc,cv,r)\r\ndimnames(dTab) = list(nLst,pLst)\r\nround(dTab,2)\r\n\r\n# Now use these calculated d-values to see if they give the right n\r\nndTab = dTab\r\nfor(i in 1:nrow(dTab)){\r\nfor(j in 1:ncol(dTab)){\r\n  ndTab[i,j] = ESS(pLst[j],dTab[i,j]) * DE(m,icc,cv)*INF(r)\r\n}}\r\nround(ndTab,1)\r\nround(ndTab,1)-nLst\r\n\r\n\r\n\r\n#\r\n# Classification\r\n#\r\n\r\npLst=seq(0.5, 0.95, by=0.05)\r\ndLst = c(1,5,10,15)/100\r\naLst = c(0.10,0.05)\r\nbLst = c(0.20,0.10)\r\n\r\nm = 15\r\nicc = 1/6\r\ncv = 0.50\r\nr = 0.15\r\n\r\n# Make Tables B-2 p.123 & B-3 p. 125 to validate ESScl\r\n# NOTE: In Table B-3 we omit rows where P0+delta>1 because that does not make sense\r\nval = expand.grid(pLst,dLst)\r\ncolnames(val) = c(\"P0\",\"delta\")\r\nval$a10b20 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.10,0.2,'below'))\r\nval$a05b20 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.05,0.2,'below'))\r\nval$a10b10 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.10,0.1,'below'))\r\nval$a05b10 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.05,0.1,'below'))\r\nTab_B_2 = val\r\nTab_B_2\r\n\r\nval = expand.grid(pLst,dLst)\r\nval = val[apply(val,1,sum)<1,]\r\ncolnames(val) = c(\"P0\",\"delta\")\r\nval$a10b20 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.10,0.2,'above'))\r\nval$a05b20 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.05,0.2,'above'))\r\nval$a10b10 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.10,0.1,'above'))\r\nval$a05b10 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.05,0.1,'above'))\r\nTab_B_3 = val\r\nTab_B_3\r\n\r\n# Calculate delta as a function of n, P0, alpha, beta\r\nval = expand.grid(pLst,dLst,aLst,bLst)\r\ncolnames(val) = c(\"P0\",\"delta\",\"alpha\",\"beta\")\r\nval$ess = apply(val,1,function(x)ESScl(x[1],x[2],x[3],x[4],'below'))\r\nval$n = val$ess * DE(m,icc,r) * INF(r)\r\nval$deltaGot = apply(val,1,function(x)getDelta(x[6],x[1],x[3],x[4],'below',m,icc,cv,r))\r\ndeltaTab = val\r\ndeltaTab","type":"text"}]
