[{"name":"app.R","content":"\r\nsetwd(\"C:/Users/JNN6/OneDrive - CDC/+My_Large_Workspace/Projects/Shiny_Learning/Shinylive_02/R\")\r\n\r\nlibrary(shiny)\r\nenableBookmarking(store = \"url\")\r\nshinyAppDir(getwd())#,list(enableBookmarking = \"url\"))\r\n\r\n","type":"text"},{"name":"server.R","content":"# A number, i.e. one or more digits [0-9] optionally immediatelly followed \r\n#   by a decimal point and one or more digits \r\n# OR\r\n# A decimal number without the leading zero\r\n# OR\r\n# A fraction, i.e. a number immediately followed by a slash \r\n#   immediately followed by a number\r\n# Note: currently does not allow numerator or denominator of fraction to be a decimal number unless it has a leading zero\r\nnumeric_input_is_valid = function(x){\r\n  grepl(\"^\\\\d+(\\\\.\\\\d+)?$\", x) | \r\n  grepl(\"^\\\\.\\\\d+$\", x) | \r\n  grepl(\"^\\\\d+(\\\\.\\\\d+)?/\\\\d+(\\\\.\\\\d+)?$\", x)\r\n}\r\n\r\n# Take the string input, convert to numeric. Handles fractions.\r\nconvert_numeric_input = function(x,nm){\r\n  x = trimws(strsplit(x,\",\")[[1]])\r\n  input_is_ok = all(numeric_input_is_valid(x))\r\n  if(input_is_ok){\r\n    val = rep(0,length(x))\r\n    for(i in 1:length(x)){\r\n      if(grepl(\"/\",x[i])){\r\n        val[i] = as.numeric(eval(parse(text=x)))\r\n      } else {\r\n        val[i] = as.numeric(x[i])\r\n      }\r\n    }\r\n    val\r\n  } else {\r\n    stop(\"Please enter only numbers and/or valid fractions separated by commas, e.g., 1/2, 3.5/4, 0.05, 200\")\r\n  }\r\n}\r\n\r\n# Provide feedback on improper inputs\r\nobserve_inputs = function(x,nm){\r\n  x = trimws(strsplit(x,\",\")[[1]])\r\n  input_is_ok = all(numeric_input_is_valid(x))\r\n  shinyFeedback::feedbackDanger(nm, !input_is_ok, \"invalid input, see error message\")\r\n}\r\n\r\n# Makes table of sample sizes for Estimation studies\r\nmake_Est_SS_Tab = function(input){\r\n    i_nm = c(\"d\",\"p\",\"m\",\"icc\",\"cv\",\"r\",\"alpha\")\r\n\ti = reactiveValues()\r\n\tfor(k in i_nm)i[[k]]=convert_numeric_input(input[[k]],k)\r\n    nOutTab(i$d,i$p,i$m,i$icc,i$cv,i$r,i$alpha)\r\n}\r\n\r\n\r\n\r\nsource(\"functions.R\")\r\nsource(\"output.R\")\r\n\r\nserver <- function(input, output, session) {\r\n\r\n  observeEvent(input$Btn_Est_SS,{observe_inputs(input$d,\"d\")})\r\n  observeEvent(input$Btn_Est_SS,{observe_inputs(input$p,\"p\")})\r\n  observeEvent(input$Btn_Est_SS,{observe_inputs(input$m,\"m\")})\r\n  observeEvent(input$Btn_Est_SS,{observe_inputs(input$icc,\"icc\")})\r\n  observeEvent(input$Btn_Est_SS,{observe_inputs(input$cv,\"cv\")})\r\n  observeEvent(input$Btn_Est_SS,{observe_inputs(input$r,\"r\")})\r\n  observeEvent(input$Btn_Est_SS,{observe_inputs(input$alpha,\"alpha\")})\r\n\r\n  # Update table on button click\r\n  updated_data = eventReactive(input$Btn_Est_SS, {\r\n    make_Est_SS_Tab(input)\r\n  })\r\n  output$ESSdf = renderTable({\r\n    updated_data()\r\n  }, striped=TRUE\r\n  )\r\n  \r\n  # Download\r\n  EstSSOutTab = reactive({make_Est_SS_Tab(input)})\r\n\t\r\n  output$ESSdfDownload = downloadHandler(\r\n    filename = \"sample_size.csv\",\r\n    content = function(file){write.csv(EstSSOutTab(),file,row.names=FALSE)}\r\n  )\r\n\r\n\r\n  # Bookmark\r\n   observe({\r\n    reactiveValuesToList(input)\r\n    session$doBookmark()\r\n  })\r\n  onBookmarked(updateQueryString)\r\n  \r\n  \r\n}\r\n","type":"text"},{"name":"ui.R","content":"\r\n\r\n# Workaround for Chromium Issue 468227\r\ndownloadButton <- function(...) {\r\n  tag <- shiny::downloadButton(...)\r\n  tag$attribs$download <- NULL\r\n  tag\r\n}\r\n\r\n\r\nui <- function(request){fluidPage(\r\n  \r\n  title = \"Cluster Survey Sample Size\",\r\n   \r\n  shinyFeedback::useShinyFeedback(),\r\n\r\n  titlePanel(\"Cluster Survey Sample Size\"),\r\n\r\n  sidebarLayout(\r\n\r\n    sidebarPanel(\r\n\r\n\t  selectInput(inputId = \"study_type\",\r\n                  label = \"Choose a Study Type:\",\r\n                  choices = c(\"Estimation\", \"Classification\", \"Comparison\")),\r\n\r\n\t  # Estimation\r\n      conditionalPanel(\r\n        condition = \"input.study_type == 'Estimation'\",\r\n        helpText(\"Enter comma-separated values, then click 'Update View'\"),\r\n\t\tselectInput(inputId = \"estimation_n_or_d\",label=\"Solve for:\",choices=c(\"Sample size\",\"Half-width CI\")),\r\n\t\tconditionalPanel(\r\n\t\t  condition = \"input.estimation_n_or_d == 'Sample size'\",\r\n          actionButton(\"Btn_Est_SS\",\"Update View\", icon(\"refresh\")),\r\n          textInput('d', 'Desired half-width CI', \"0.05, 0.10\")\r\n\t\t ),\r\n\t\tconditionalPanel(\r\n\t\t  condition = \"input.estimation_n_or_d == 'Half-width CI'\",\r\n          actionButton(\"Btn_Est_CI\",\"Update View\", icon(\"refresh\")),\r\n          textInput('n', 'Sample size', \"300, 900\"),\r\n\t\t ),\r\n        textInput('p', 'Expected coverage proportion', \"0.10, 0.25\"),\r\n        textInput('m', 'Target number of respondents per cluster', \"5, 15\"),\r\n        textInput('icc', 'intracluster correlation coefficient', \"1/22, 1/6\"),\r\n        textInput('cv', 'Coefficient of variation of sample weights', \"0.50\"),\r\n        textInput('r', 'Anticipated non-response rate, from 0 to 1', \"0.15\"),\r\n        textInput('alpha', 'Type I error rate; usually 0.05 for 95% CI', \"0.05\")\r\n\r\n      ),\r\n\t  \r\n\t  # Classification\r\n      conditionalPanel(\r\n        condition = \"input.study_type == 'Classification'\",\r\n        numericInput(\"num\", \"Enter a number:\", value = 1)\r\n      ),\r\n\t  \r\n\t  # Comparison\r\n      conditionalPanel(\r\n        condition = \"input.study_type == 'Comparison'\",\r\n        textInput(\"text\", \"Enter text:\")\r\n      ),\r\n\t  \r\n    ),\r\n\r\n    # Main panel\r\n    mainPanel(\r\n\t  # Bookmark feature not currently supported in Shinylive\r\n      #fluidRow(downloadButton(\"ESSdfDownload\",\"Download\"), bookmarkButton()),\r\n\t  fluidRow(downloadButton(\"ESSdfDownload\",\"Download\")),\r\n      fluidRow(tableOutput(\"ESSdf\"))\r\n    )\r\n\t\r\n\t\r\n  )\r\n)}\r\n","type":"text"},{"name":"Compile_Shinylive_App.R","content":"\r\nsetwd(\"C:/Users/JNN6/OneDrive - CDC/GitHub/Study_Design_Tools_for_Complex_Cluster_Surveys/R\")\r\n\r\n# Check that it runs properly on local machine\r\nshiny::runApp()\r\n\r\n# Compile into serverless web app\r\nshinylive::export(appdir = getwd(), destdir = \"../docs\")\r\n\r\n# Check that the serverless web app works properly\r\nhttpuv::runStaticServer(\"../docs\")\r\n","type":"text"},{"name":"_run_Classification.R","content":"## rm(list=ls());gc()\r\n\r\n#\r\n# R code\r\n# Implements functionalities for study design from:\r\n#   Vaccination Coverage Cluster Surveys: Reference Manual. \r\n#   Geneva: World Health Organization; 2018 (WHO/IVB/18.09). \r\n#   Licence: CC BY-NC-SA 3.0 IGO.\r\n#   Ordering code: WHO/IVB/18.09\r\n#\r\n# Page numbers refer to this document\r\n#\r\n# Terms and Parameters used:\r\n#   Delta = [ ... will include code to calculate this for given n ...]\r\n#\r\n#   ESScl = Effective Sample Size; p.131\r\n#     ESScl(P0, delta, alpha, beta, direction)\r\n#     P0 = the programmatic threshold\r\n#     delta = a coverage percent defining a distance from P0\r\n#     alpha = Type I error\r\n#     beta = Type II error\r\n#   DEFF = Design Effect; p.110\r\n#     DE(m,icc,cv)\r\n#     m = target number of respondents per cluster; p.109\r\n#     icc = intracluster correlation coefficient; p.109\r\n#     cv = coefficient of variation of sample weights\r\n#   INF = Inflation factor to account for non-response; p.112, 128\r\n#     INF(r)\r\n#     r = anticipated non-response rate, from 0 to 1\r\n#\r\n# Outline:\r\n#   * Computation functions\r\n#   * Validation of computation functions\r\n#   * Output functions\r\n#   * Example usage\r\n#\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Setup\r\n#\r\n\r\n# set working directory as git repo root\r\nsetwd(\"C:/Users/JNN6/OneDrive - CDC/GitHub/cluster_survey_sample_size\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Computation functions\r\n#\r\n# ESScl(P0, delta, alpha, beta, direction)\r\n# DE(m,icc=1/6,cv=0.05)\r\n# INF(r)\r\n# halfWidthCI(n,p,m,icc,cv,r,alpha=0.05)\r\n\r\nsource(\"R/functions.R\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Validation of computation functions\r\n#\r\n\r\nsource(\"R/validation.R\")\r\n\r\n# Recreate Tables B-2 p.123 & B-3 p. 125 to validate ESScl\r\n# (d,p)\r\nTab_B_2\r\nTab_B_3\r\n\r\n# delta calculated as a function of n, P0, alpha, beta, direction\r\ndeltaTab\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Output functions\r\n#\r\n# nclOutTab(P0,delta,alpha,beta,direction,m,icc,cv,r)\r\n\r\nsource(\"R/output.R\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Example usage\r\n#\r\n\r\n# Some example inputs\r\np = c(.7,.8)\r\nd = c(.01,.05)\r\na = c(.1,.05)\r\nb = c(.2,.1)\r\nm = c(5,15)\r\nicc = c(1/22,1/6)\r\ncv = c(0.50)\r\nr = c(15)/100\r\n\r\n# Compute sample size required for various inputs\r\nexTab = nclOutTab(p,d,a,b,'below',m,icc,cv,r)[[1]]\r\n\r\n# Compute delta for given n and everything else\r\nexTab$deltaGot = apply(exTab,1,function(x)\r\n  getDelta(x[12],x[1],x[3],x[4],'below',x[5],x[6],x[7],x[8])\r\n)\r\nexTab\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# n = c(7000,500)\r\n# P0 = c(.7,.8)\r\n# alpha = c(.1)\r\n# beta = c(.2)\r\n# direction = 'below'\r\n# m = c(5)\r\n# icc = c(1/22)\r\n# cv = c(0.50)\r\n# r = c(15)/100\r\n# #n = c(9363,7418,411,328,13165,10115,554,438,\r\n# #        14024,10804,595,476,18230,14023,766,609)\r\n# \r\n# \r\n# \r\n# # Find delta given n (and everything else)\r\n# #\r\n# deltaOutput = function(n, P0, alpha, beta, direction, m, icc, cv, r){\r\n#   val=expand.grid(n,P0,alpha,beta,m,icc,cv,r)\r\n#   colnames(val) = c(\"n\",\"P0\",\"alpha\",\"beta\",\"m\",\"icc\",\"cv\",\"r\")\r\n#   val$delta = apply(val,1,function(x)\r\n#       getDelta(x[1],x[2],x[3],x[4],direction,x[5],x[6],x[7],x[8])\r\n#     )\r\n#   val\r\n# } \r\n# \r\n# \r\n# \r\n# deltaOutput(n,P0,alpha,beta,'below',m,icc,cv,r)\r\n#val$direction = as.character(val$direction)\r\n#val = val[!(val$direction=='below' & val$P0-val$delta<0),]\r\n#val = val[!(val$direction=='above' & val$P0+val$delta>1),]\r\n","type":"text"},{"name":"_run_Estimation.R","content":"## rm(list=ls());gc()\r\n\r\n#\r\n# R code\r\n# Implements functionalities for study design from:\r\n#   Vaccination Coverage Cluster Surveys: Reference Manual. \r\n#   Geneva: World Health Organization; 2018 (WHO/IVB/18.09). \r\n#   Licence: CC BY-NC-SA 3.0 IGO.\r\n#   Ordering code: WHO/IVB/18.09\r\n#\r\n# Page numbers refer to this document\r\n#\r\n# Terms and Parameters used:\r\n#   CI = Confidence Interval\r\n#     halfWidthCI(n,p,m,icc,cv,r,alpha)\r\n#       finds the half-width CI (d) for a given sample size and design\r\n#     n = sample size\r\n#     all other terms defined below\r\n#   ESS = Effective Sample Size; p.129\r\n#     ESS(p,d,alpha)\r\n#     p = expected coverage proportion\r\n#     d = desired half-width of the CI\r\n#     alpha = the probability value used to define the precision for \r\n#             estimated CIs; usually 0.05 for 95% CI\r\n#   DEFF = Design Effect; p.110\r\n#     DE(m,icc,cv)\r\n#     m = target number of respondents per cluster; p.109\r\n#     icc = intracluster correlation coefficient; p.109\r\n#     cv = coefficient of variation of sample weights\r\n#   INF = Inflation factor to account for non-response; p.112, 128\r\n#     INF(r)\r\n#     r = anticipated non-response rate, from 0 to 1\r\n#\r\n# Outline:\r\n#   * Computation functions\r\n#   * Validation of computation functions\r\n#   * Output functions\r\n#   * Example usage\r\n#\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Setup\r\n#\r\n\r\n# set working directory as git repo root\r\nsetwd(\"C:/Users/JNN6/OneDrive - CDC/GitHub/cluster_survey_sample_size\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Computation functions\r\n#\r\n# ESS(p,d,alpha=0.05)\r\n# DE(m,icc=1/6,cv=0.05)\r\n# INF(r)\r\n# halfWidthCI(n,p,m,icc,cv,r,alpha=0.05)\r\n\r\nsource(\"R/functions.R\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Validation of computation functions\r\n#\r\n\r\nsource(\"R/validation.R\")\r\n\r\n# Recreate Table B-1 p.118 to validate ESS\r\n# (d,p)\r\nTab_B_1\r\n\r\n\r\n# d calculated as a function of n & p\r\n# (n,p)\r\nround(dTab,2)\r\n\r\n# Do the calculated d give back the correct n?\r\n# (n,p)\r\nround(ndTab,1)\r\n\r\n# Close ... what's the difference?\r\nround(ndTab,1)-nLst\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Output functions\r\n#\r\n# nOutTab(p,d,m,icc,cv,r,alpha)\r\n# dOutTab(n,p,m,icc,cv,r,alpha)\r\n\r\nsource(\"R/output.R\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Example usage\r\n#\r\n\r\n# Some example inputs\r\nn = c(300,900)\r\nd = c(5,10)/100\r\np = c(0.10,0.25)\r\nm = c(5,15)\r\nicc = c(1/22,1/6)\r\ncv = c(0.50)\r\nr = c(15)/100\r\nalpha = c(0.05)\r\n\r\n# Compute sample size required for various inputs\r\nnOutTab(d,p,m,icc,cv,r,alpha)\r\n\r\n# Compute study's half-width CI for various sample sizes & other inputs\r\ndOutput(n,p,m,icc,cv,r,alpha)\r\n\r\n\r\n\r\n# Some example inputs\r\nn = seq(100,1000,by=100)\r\np = c(0.05,0.25)\r\nm = 15\r\nicc = 1/6\r\ncv = 0.50\r\nr = 15/100\r\nalpha = 0.05\r\n\r\n# Examine how d changes for varying n\r\ndPlot = outer(n,p,Vectorize(halfWidthCI),m,icc,cv,r)\r\nplot(n,dPlot[,1],type='l')\r\nlines(n,dPlot[,2],col='red')\r\n\r\n# See how well d was computed (or not)\r\nsapply(dPlot,function(x)ESS(0.05,x)* DE(m,icc,cv)*INF(r))\r\n\r\n\r\n","type":"text"},{"name":"functions.R","content":"\r\n\r\n\r\n#\r\n# Estimation\r\n#\r\n\r\n# ESS Effective Sample Size eq. B2-1 for ESS p.129\r\nESS = function(p,d,alpha=0.05){\r\n  if(p<0|p>1)stop(\"p must be a number from 0 to 1\")\r\n  if(d<=0|d>=0.3)stop(\"d must be a number between 0 and 0.3\")\r\n  if(alpha<=0|alpha>=1)stop(\"alpha must be a number between 0 and 1\")\r\n  # Calculate k according to Table K on p.129\r\n  k=1\r\n  if(p<d|p>1-d)k=8*d*(1-2*d)\r\n  if(p>=d&p<0.3)k=4*(p+d)*(1-p-d)\r\n  if(p>0.7&p<=1-d)k=4*(p-d)*(1-p+d)\r\n  z=qnorm(1-alpha/2)\r\n  ceiling(k*z^2/4/d^2 + 1/d - 2*z^2 + (z+2)/k)\r\n}\r\n\r\n\r\n# Solve for d for given n, p, m, icc, cv, r, alpha\r\nhalfWidthCI = function(n,p,m,icc,cv,r,alpha=0.05){\r\n  deff = DE(m,icc,cv)\r\n  inf = INF(r)\r\n  ess = n/deff/inf\r\n  z = qnorm(1-alpha/2)\r\n  \r\n  f = function(d,ess,p,z){\r\n    k=1\r\n    if(p<d|p>1-d)k=8*d*(1-2*d)\r\n    if(p>=d&p<0.3)k=4*(p+d)*(1-p-d)\r\n    if(p>0.7&p<=1-d)k=4*(p-d)*(1-p+d)\r\n    (  ess - (k*z^2/4/d^2 + 1/d - 2*z^2 + (z+2)/k)  )^2\r\n  }\r\n  optimize(f,c(0,1),ess=ess,p=p,z=z)$minimum\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Classification\r\n#\r\n\r\n# ESS Effective Sample Size for classification eq. B2-3 p.131\r\nESScl = function(P0, delta, alpha, beta, direction){\r\n  if(P0<0|P0>1)stop(\"P0 must be a number from 0 to 1\")\r\n  if(alpha<=0|alpha>=1|beta<=0|beta>=1)stop(\"alpha & beta must be a number between 0 and 1\")\r\n  dir = tolower(direction)\r\n  if(!dir %in% c('above','below'))stop(\"direction must be either 'above' or 'below' (case-insensitive)\")\r\n  if(dir=='above' & P0+delta>1)stop(\"P0+delta>1\")\r\n  if(dir=='below' & P0-delta<0)stop(\"P0-delta<0\")\r\n  if (dir=='above') {P1=P0+delta} else {P1=P0-delta}\r\n  z1=qnorm(1-alpha)\r\n  z2=qnorm(1-beta)  \r\n  n_0 = ((z1*sqrt(P0*(1-P0))+z2*sqrt(P1*(1-P1)))/(P1-P0))**2\r\n  ceiling((n_0/4)*(1+sqrt(1+2/(n_0*abs(delta))))**2)\r\n}\r\n\r\n\r\n# Solve for delta for given n, P0, alpha, beta, direction, m, icc, cv, r\r\ngetDelta = function(n, P0, alpha, beta, direction, m, icc, cv, r){\r\n  dir = tolower(direction)\r\n  deff = DE(m,icc,cv)\r\n  inf = INF(r)\r\n  ess = n/deff/inf\r\n  z1=qnorm(1-alpha)\r\n  z2=qnorm(1-beta)  \r\n  \r\n  f = function(delta,ess,P0,z1,z2){\r\n    if (dir=='above') {P1=P0+delta} else {P1=P0-delta}\r\n    n_0 = ((z1*sqrt(P0*(1-P0))+z2*sqrt(P1*(1-P1)))/(P1-P0))**2\r\n    x = (n_0/4)*(1+sqrt(1+2/(n_0*abs(delta))))**2\r\n    (ess-x)**2\r\n  }\r\n  optimize(f,c(0,1),ess=ess,P0=P0,z1=z1,z2=z2)$minimum\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# General\r\n#\r\n\r\n\r\n# DEFF Design Effect p.110 equation for DEFF\r\nDE = function(m,icc=1/6,cv=0.50){\r\n (1+(m-1)*icc)*(1+cv^2)\r\n}\r\n\r\n\r\n# Inflation factor due to non-response; p.112\r\n# Note: r %in% (0,1)\r\nINF = function(r)1/(1-r)\r\n\r\n\r\n\r\n\r\n","type":"text"},{"name":"output.R","content":"\r\n\r\n#\r\n# Estimation\r\n#\r\n\r\n# Each input can be a single number or a list of numbers.\r\n# Note that a data.frame is output with number of rows equal to\r\n#   the product of the lengths of the input lists ... so it can get\r\n#   large quickly.\r\n\r\n# Make a table of sample sizes.\r\n# Output columns:\r\n#  ess(p,d,alpha) Effective Sample Sizes\r\n#  deff(m,icc,cv) Design Effect \r\n#  inf(f) Inflation Factor\r\n#  n(ess,deff,inf) Sample Size\r\n#  nc(n,m) Number of Clusters\r\nnOutTab = function(d,p,m,icc=1/6,cv=0.50,r,alpha=0.05){\r\n  val=expand.grid(p,d,alpha,m,icc,cv,r)\r\n  colnames(val) = c(\"p\",\"d\",\"alpha\",\"m\",\"icc\",\"cv\",\"r\")\r\n  val$ess=apply(val[,c(\"d\",\"p\")],1,function(x)ESS(x[2],x[1]))\r\n  val$deff=DE(val$m,icc=val$icc,cv=val$cv)\r\n  val$inf=INF(val$r)\r\n  val$n = ceiling(val$ess * val$deff * val$inf)\r\n  val$nc = ceiling(val$n / val$m)\r\n  colnames(val) = c(\r\n    \"p\",\"d\",\"alpha\",\"m\",\"icc\",\"cv\",\"r\",\r\n    \"ess(p,d,alpha)\",\"deff(m,icc,cv)\",\"inf(r)\",\"n(ess,deff,inf)\",\r\n    \"nc(n,m)\"\r\n  )\r\n  val\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Find half-width of CI given n (and everything else)\r\n#\r\ndOutput = function(n,p,m,icc=1/6,cv=0.50,r,alpha=0.05){\r\n  val=expand.grid(n,p,m,icc,cv,r,alpha)\r\n  colnames(val) = c(\"n\",\"p\",\"m\",\"icc\",\"cv\",\"r\",\"alpha\")\r\n  val$d = apply(val,1,function(x)\r\n      halfWidthCI(x[1],x[2],x[3],x[4],x[5],x[6],x[7])\r\n    )\r\n  val\r\n} \r\n\r\n\r\n\r\n\r\n\r\n\r\n#\r\n# Classification\r\n#\r\n\r\nnclOutTab = function(P0,delta,alpha,beta,direction,m,icc,cv,r){\r\n  dir = tolower(direction)\r\n  # Only do either above or below but not both in the same table\r\n  if(!dir %in% c('above','below'))stop(\"direction must be either 'above' or 'below' (case-insensitive). This function only allows for creating an output table for one or the other 'above' or 'below' but not both.\")\r\n  val=expand.grid(P0,delta,alpha,beta,m,icc,cv,r)\r\n  colnames(val) = c(\"P0\",\"delta\",\"alpha\",\"beta\",\"m\",\"icc\",\"cv\",\"r\")\r\n  val$ess=apply(val[,c(\"P0\",\"delta\",\"alpha\",\"beta\")],1,function(x)ESScl(x[1],x[2],x[3],x[4],dir))\r\n  val$deff=DE(val$m,icc=val$icc,cv=val$cv)\r\n  val$inf=INF(val$r)\r\n  val$n = ceiling(val$ess * val$deff * val$inf)\r\n  val$nc = ceiling(val$n / val$m)\r\n  colnames(val) = c(\r\n    \"P0\",\"delta\",\"alpha\",\"beta\",\"m\",\"icc\",\"cv\",\"r\",\r\n    \"ess(P0,delta,alpha,beta,direction)\",\"deff(m,icc,cv)\",\"inf(r)\",\r\n    \"n(ess,deff,inf)\",\"nc(n,m)\"\r\n  )\r\n  list(Table=val, direction=dir)\r\n}","type":"text"},{"name":"validation.R","content":"\r\n\r\n#\r\n# Estimation\r\n#\r\n\r\ndLst = seq(0.03,0.10,by=0.01)\r\npLst = c(seq(0.05,0.25,by=0.05),0.50,seq(0.75,0.95,by=0.05))\r\nnLst = seq(100,1000,by=100)\r\n\r\nm = 15\r\nicc = 1/6\r\ncv = 0.50\r\nr = 0.15\r\n\r\n# Make Table B-1 p.118 to validate ESS\r\nTab_B_1 = t(outer(pLst,dLst,Vectorize(ESS)))\r\ndimnames(Tab_B_1) = list(dLst,pLst)\r\nTab_B_1\r\n\r\n\r\n# Calculate d as a function of n & p\r\ndTab = outer(nLst,pLst,Vectorize(halfWidthCI),m,icc,cv,r)\r\ndimnames(dTab) = list(nLst,pLst)\r\nround(dTab,2)\r\n\r\n# Now use these calculated d-values to see if they give the right n\r\nndTab = dTab\r\nfor(i in 1:nrow(dTab)){\r\nfor(j in 1:ncol(dTab)){\r\n  ndTab[i,j] = ESS(pLst[j],dTab[i,j]) * DE(m,icc,cv)*INF(r)\r\n}}\r\nround(ndTab,1)\r\nround(ndTab,1)-nLst\r\n\r\n\r\n\r\n#\r\n# Classification\r\n#\r\n\r\npLst=seq(0.5, 0.95, by=0.05)\r\ndLst = c(1,5,10,15)/100\r\naLst = c(0.10,0.05)\r\nbLst = c(0.20,0.10)\r\n\r\nm = 15\r\nicc = 1/6\r\ncv = 0.50\r\nr = 0.15\r\n\r\n# Make Tables B-2 p.123 & B-3 p. 125 to validate ESScl\r\n# NOTE: In Table B-3 we omit rows where P0+delta>1 because that does not make sense\r\nval = expand.grid(pLst,dLst)\r\ncolnames(val) = c(\"P0\",\"delta\")\r\nval$a10b20 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.10,0.2,'below'))\r\nval$a05b20 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.05,0.2,'below'))\r\nval$a10b10 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.10,0.1,'below'))\r\nval$a05b10 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.05,0.1,'below'))\r\nTab_B_2 = val\r\nTab_B_2\r\n\r\nval = expand.grid(pLst,dLst)\r\nval = val[apply(val,1,sum)<1,]\r\ncolnames(val) = c(\"P0\",\"delta\")\r\nval$a10b20 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.10,0.2,'above'))\r\nval$a05b20 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.05,0.2,'above'))\r\nval$a10b10 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.10,0.1,'above'))\r\nval$a05b10 = apply(val[,1:2],1,function(x)ESScl(x[1],x[2],0.05,0.1,'above'))\r\nTab_B_3 = val\r\nTab_B_3\r\n\r\n# Calculate delta as a function of n, P0, alpha, beta\r\nval = expand.grid(pLst,dLst,aLst,bLst)\r\ncolnames(val) = c(\"P0\",\"delta\",\"alpha\",\"beta\")\r\nval$ess = apply(val,1,function(x)ESScl(x[1],x[2],x[3],x[4],'below'))\r\nval$n = val$ess * DE(m,icc,r) * INF(r)\r\nval$deltaGot = apply(val,1,function(x)getDelta(x[6],x[1],x[3],x[4],'below',m,icc,cv,r))\r\ndeltaTab = val\r\ndeltaTab","type":"text"}]
